<!DOCTYPE html>
<html prefix="og: https://ogp.me/ns#" lang="en">

  <head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="author" content="">

  <title>An overview of the WPE WebKit project</title>
  <link rel="canonical" href="https://igalia.github.io/wpewebkit.org/aperezdc/blog-extending/blog/02-overview-of-wpe.html">
  <link rel="alternate" type="application/rss+xml" title="" href="https://igalia.github.io/wpewebkit.org/aperezdc/blog-extending/feed.xml">
  <meta property="og:url" content="https://igalia.github.io/wpewebkit.org/aperezdc/blog-extending/blog/02-overview-of-wpe.html">
  <meta property="og:title" content="An overview of the WPE WebKit project">
  <meta property="og:image" content="https://igalia.github.io/wpewebkit.org/aperezdc/blog-extending/assets/twitter_Profile_WhiteBg_400px.png">
  <meta property="og:image:secure_url" content="https://igalia.github.io/wpewebkit.org/aperezdc/blog-extending/assets/twitter_Profile_WhiteBg_400px.png">
  <meta property="og:image:alt" content="WPE logo">
  <meta property="og:image:type" content="image/png">
  <meta property="og:image:width" content="400">
  <meta property="og:image:height" content="400">
  <meta property="og:type" content="article">
  <meta property="article:published_time" content="2022-07-01T00:00:00.000Z">
  <meta property="article:tag" content="blogpost">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@WPEWebKit">

  <!-- CSS v2 -->
  <link rel="stylesheet" href="/wpewebkit.org/aperezdc/blog-extending/css/v2.css">

  <!-- Custom Fonts -->
  <link rel="stylesheet" href="/wpewebkit.org/aperezdc/blog-extending/vendor/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/wpewebkit.org/aperezdc/blog-extending/css/fonts.css">

  <!-- Code syntax highlighting -->
  <link rel="stylesheet" href="/wpewebkit.org/aperezdc/blog-extending/css/prism.css">

  <!-- Custom CSS -->
  <link rel="stylesheet" href="/wpewebkit.org/aperezdc/blog-extending/css/stylish-portfolio.css">
  <script type="text/javascript">
    window.addEventListener('load',function() {document.querySelector('nav.global>div>.burger').addEventListener('click',menutog)});
    function menutog(e) {
      document.querySelector('nav.global>div>ul').classList.toggle('off');
      e.preventDefault();
    }
  </script>
  <!-- Matomo -->
  <script type="text/javascript">
    var _paq = window._paq = window._paq || [];
    /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
      var u="//stats.igalia.com/";
      _paq.push(['setTrackerUrl', u+'matomo.php']);
      _paq.push(['setSiteId', '6']);
      var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
      g.type='text/javascript'; g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
    })();
  </script>
  <!-- End Matomo Code -->
  
</head>


  <body id="page-top" class="subpage">

    <nav class="global">
	<div>
		<a class="igalia logo home" href="/wpewebkit.org/aperezdc/blog-extending/"><img src="/wpewebkit.org/aperezdc/blog-extending/assets/img/logo-blue.svg" alt="WPE"></a>
		<ul class="blog off"><li>
			<a class="nav-link" href="/wpewebkit.org/aperezdc/blog-extending/">Home</a>
			</li><li>
			<a class="nav-link" href="/wpewebkit.org/aperezdc/blog-extending/about">Learn & Discover</a>
			</li><li class="currentPage">
			<a class="nav-link" href="/wpewebkit.org/aperezdc/blog-extending/blog">Blog</a>
			</li><li>
			<a class="nav-link" href="/wpewebkit.org/aperezdc/blog-extending/developers">Developers</a>
			</li><li>
			<a class="btn cta" href="/wpewebkit.org/aperezdc/blog-extending/about/explore-wpe.html">Get Started</a>
			</li></ul>
		<a href="#" class="burger">Menu</a>
	</div>
</nav>


    <main>
    <style>
header.page h1 {
	margin-bottom: 0.33em;
	line-height: 1;
}
header.page time {
	font-size: 1.25em;
	opacity: 0.67;
}
</style>
<div itemscope itemtype="http://schema.org/TechArticle">
<meta itemprop="creativeWorkStatus" content="Published">
<meta itemprop="isAccessibleForFree" content="True">
<meta itemprop="publisher" content="WPE Team">
<meta itemprop="author" content="WPE Team">
<meta itemprop="url" content="https://igalia.github.io/wpewebkit.org/aperezdc/blog-extending/blog/02-overview-of-wpe.html">

<header class="page full-bleed">
 <h1 itemprop="headline">An overview of the WPE WebKit project</h1>
 
   <meta itemprop="datePublished" content="Fri Jul 01 2022">
   <time itemprop="dateCreated"> 1 July 2022</time>
 
  
</header>

<div itemprop="articleBody">

<p>In <a href="/wpewebkit.org/aperezdc/blog-extending/blog/01-happy-birthday-wpe.html">the previous post in this series</a>,
we explained that WPE is a WebKit
port optimized for embedded devices. In this post, we’ll dive into a
more technical overview of the different components of WPE, WebKit,
and how they all fit together. If you’re still wondering what a web
engine is or how WPE came to be, we recommend you to go back to the
first post in the series and then come back here.</p>
<h2 id="webkit-architecture-in-a-nutshell" tabindex="-1">WebKit architecture in a nutshell</h2>
<p>To understand what makes WPE special, we first need to have a basic
understanding of the architecture of WebKit itself, and how it ties
together a given architecture/platform and a user-facing web browser.</p>
<p>WebKit, the engine, is split into different components that
encapsulate its different parts. At the heart of it is WebCore. As the
name suggests, this contains the core features of the engine
(rendering, layout, platform access, HTML and DOM support, the
graphics layer, etc). However, some of these ultimately depend heavily
on the OS and underlying software platform in order to function. For
example: how do we actually do any I/O on different platforms? How do
we render onscreen? What’s the underlying multimedia platform and how
does it decode media and play it?</p>
<p>WebCore handles the multitude of potential answers to these questions
by abstracting the implementation of each component and allowing port
developers to fill the gaps for each supported platforms. For example,
for rendering on Mac, Cocoa APIs implement the graphics APIs
needed. On Linux, this can be done through different implementations
via Wayland, Vulkan, etc. For networking I/O on Mac, the networking
APIs in the Foundation framework are used. On Linux, libsoup fills
that gap, and so on.</p>
<p>On the opposite side, for browser implementors to be able to write a
browser using WebKit, an API is needed. WebKit, after all, is a
library. WebKit ports, besides providing the platform support
described above, also provide APIs that suit the target environments:
The Apple ports provide Objective-C APIs (which are then used to write
Safari and the iOS browsers, for instance), while the GTK+ port
provides a GObject-based APIs for Linux (that are used in Epiphany,
the GNOME browser, and other GNOME applications that rely on WebKit to
render HTML). All of these APIs are built on top of an internal,
middle-man, C API that is meant to make it easy for each port to
provide a high-level API for browser developers.</p>
<p>With all this in place, it would seem that it shouldn’t be so
difficult for any vendor trying to reuse WebKit in a new platform to
support new hardware and implement a browser, right? All that you need
to do is:</p>
<ul>
<li>Implement backends that integrate with your hardware platform: for
multimedia, IO, OS support, networking, graphics, etc.</li>
<li>Write an API that you can use to plug the engine into your browser.</li>
<li>Maintain the changes needed off-tree, that is, outside the source code tree
of WebKit.</li>
<li>Keep your implementation up-to-date with the many changes that happen in the
WebKit codebase on a daily basis, so that you can update WebKit regularly
and take advantage of the many bug fixes, improvements, and new features
that land on WebKit continuously.</li>
</ul>
<p>Does that sound easy? No, it’s not easy at all! In fact,
implementation of ports in this fashion is strongly discouraged and
vendors who have tried this approach in the past have had to do a huge
effort just to play catch-up with the fast-paced development of
WebKit. This is where WPE comes to the rescue.</p>
<h2 id="simplifying-browsers-development-in-the-diverse-embedded-world" tabindex="-1">Simplifying browsers development in the diverse embedded world</h2>
<p>To simplify the task of porting WebKit to different platforms, Igalia
started working on a platform-agnostic, Linux-based, and full-featured
port of WebKit. This port relies on existing and mature platform
backends for everything that can be easily reused across platforms:
multimedia, networking, and I/O, which are already present in-tree and
are used by Linux ports, like the GTK one. For the areas that are most
likely to require hardware-specific support (that is, graphics and
input), WPE abstracts the implementation so that it can be more easily
provided out of tree, allowing implementors to avoid having to deal
with the WebKit internals more than what’s strictly needed.</p>
<p>Additionally, WPE provides a high-level API that can be used to
implement actual browsers. This API is very similar to the WebKitGTK
API, making it easy for developers already familiar with the latter to
start working with WPE. The cog library also serves as a wrapper
around WPE to make it easier still. Once WPE was mature enough, it was
accepted by Apple as an official WebKit port, meaning that the port
lives now in-tree and takes immediate advantage of the many
improvements that land on the WebKit repository on a daily basis.</p>
<h2 id="how-does-wpe-integrate-with-webkit%3F" tabindex="-1">How does WPE integrate with WebKit?</h2>
<p><img style="display: block; margin: 1em auto;"
	alt="A diagram of the WPE WebKit architecture"
	src="/wpewebkit.org/aperezdc/blog-extending/assets/wpe-architecture-diagram.png"></p>
<p>The WPE port has several components. Some are in-tree (that is, are a
part of WebKit itself), while others are out-of-tree. Let’s examine
those components and how they relate to each other, from top to
bottom:</p>
<ul>
<li>The <a href="https://github.com/Igalia/cog#cog">Cog library</a>.
While not an integral part of WPE, libcog is a shell library that simplifies
the task of writing a WPE browser from the scratch, by providing common
functionality and helper APIs. This component also includes the cog browser,
a simple WPE browser built on top of libcog that can be used as a reference
or a starting point for the development of a new browser for a specific use
case.</li>
<li>The <a href="https://people.igalia.com/aperez/Documentation/wpe-webkit-1.1/">WPE WebKit API</a>:
the entry point for browser developers to the WebKit engine, provides a
comprehensive GObject/C API. The cog library uses this API extensively and
we recommend relying on it, but for more specific needs and more fine-tuning
of the engine, working directly with the WebKit API can be often necessary.
The API is stable and easy to use, especially, and for those familiar with
the GTK/GNOME platform.</li>
<li>WPE’s WebCore implementation: This part, internal to WebKit, implements
an abstraction of the graphics and input layers of WebKit. This
implementation relies on the libwpe library to provide the functionality
required in an abstract way. Thanks to the architecture of WPE, implementors
don’t need to bother with the complexities of WebCore and WebKit internals.</li>
<li>The <a href="https://github.com/WebPlatformForEmbedded/libwpe">libwpe</a>
library. This is an out-of-tree library that provides the API required by
the WPE port in a generic way to implement the graphical and input backends.
Specific functionality for a concrete platform is not provided, but the
library relies on the existence of a backend implementation, as is described
next.</li>
<li>Finally, a WPE backend implementation. This is where all the
platform-specific code lives. Backends are loadable modules that can be
chosen depending on the underlying hardware. These should provide access to
graphics and input depending on the specific architecture, platform, and
operating system requirements. As a reference, <a
href="https://github.com/Igalia/WPEBackend-fdo">WPEBackend-fdo</a> is a
freedesktop.org-based backend, which uses Wayland and freekdesktop.org
technologies, and is <a href="/wpewebkit.org/aperezdc/blog-extending/about/supported-hardware.html">
supported for several architectures</a>, including NXP and Broadcom chipsets, like the
Raspberry Pi, and also regular PC architectures, easing testing and
development.</li>
</ul>
<p>An implementor interested in building a browser in a new architecture
only needs to focus on the development of the last component – a WPE
backend. Having a backend, starting the development of a
WebKit-powered browser is already much easier than it ever was!</p>
<p>For a more detailed description of the architecture of WPE and WebKit,
check this article on <a href="/wpewebkit.org/aperezdc/blog-extending/about/architecture.html">the architecture of WPE</a>.</p>
<h2 id="ok%2C-sounds-interesting%2C-how-do-i-get-my-hands-dirty%3F" tabindex="-1">OK, sounds interesting, how do I get my hands dirty?</h2>
<p>If you have made it this far, you should give WPE a try!</p>
<p>We have listed several on the <a href="/wpewebkit.org/aperezdc/blog-extending/about/exploring.html">exploring WPE</a>
page. From there, you will see that depending on how interested you
are in the project, your background, and what you’d like to do with
it, there are different ways!</p>
<p>It can be as easy as installing WPE directly from the most popular
Linux distributions or downloading and flashing prebuilt images for
the Raspberry Pi. There are easy and flexible options like
<a href="/wpewebkit.org/aperezdc/blog-extending/about/flatpak.html">Flatpak</a> or
<a href="/wpewebkit.org/aperezdc/blog-extending/about/balena-wpe.html">Balena</a>, which
you can dig into to learn more. If you want to build WPE yourself,
you can use <a href="https://github.com/Igalia/meta-webkit/wiki/WPE">Yocto</a> and if
you’d like to contribute—that’s very welcome!</p>
<p>Happy hacking!</p>



<section class="content-section bg-light small-section">
  <div class="container">
    <div class="row">
      <div class="col-lg-10 mx-auto text-muted text-left align-text-top">
        <hr class="author-line">
        <div class="card">
          <span>
            This article was written by <a href="https://www.igalia.com/team/csaavedra">Claudio Saavedra</a>. <br><br>Claudio is long-time WebKit contributor from Igalia, working in different areas of WebKit, WPE, and the stack around it.
          </span>
        </div>
      </div>
    </div>
  </div>
</section>



</div>

    </main>

    <footer class="global">
	<b></b>
	<div>
		<a href="/wpewebkit.org/aperezdc/blog-extending/" class="igalia logo home"><img src="/wpewebkit.org/aperezdc/blog-extending/assets/img/logo-white.svg" alt="WPE"></a>
		<ul>
			<li>Connect on <a rel="me" href="https://floss.social/@WPEWebKit">Mastodon</a>, <a href="https://twitter.com/WPEWebKit">Twitter</a></li>
			<li>mailing list: <a href="https://lists.webkit.org/mailman/listinfo/webkit-wpe">webkit-wpe</a></li>
			<li>OFTC: <a href="https://webchat.oftc.net/?channels=wpe">#wpe</a></li>
			<li>Matrix: <a href="https://matrix.to/#/#wpe:matrix.org">#wpe:matrix.org</a></li>
		</ul>
		<ul>
			<li>Copyright &copy; 2018-2023 The WPE WebKit Team</li>
			<li>Hosting kindly provided by <a href="https://www.igalia.com">Igalia</a>.</li>
		</ul>
	</div>
</footer>


  </body>
</html>
