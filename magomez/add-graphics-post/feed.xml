<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WPEwebkit.org</title>
  <description>Release announcements and security advisories from WPEwebkit.org.</description>
  <link href="https://wpewebkit.org/feed.xml" rel="self"/>
  <link href="https://wpewebkit.org/"/>
  <updated>2022-07-15T00:00:00Z</updated>
  <id>https://wpewebkit.org/</id>
  
  <entry>
    <title>WPE Graphics architecture</title>
    <link href="https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/blog/03-wpe-graphics-architecture.html"/>
    <updated>2022-07-15T00:00:00Z</updated>
    <id>https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/blog/03-wpe-graphics-architecture.html</id>
    <content type="html">&lt;p&gt;Following &lt;a href=&quot;https://wpewebkit.org/blog/02-overview-of-wpe.html&quot;&gt;the
previous post in the series about WPE&lt;/a&gt; where we talked about the WPE components,
this post will explain briefly the WPE graphics architecture, and how the engine
is able to render HTML content into the display. If you haven’t read the previous
entries in this blog post series about WPE, we recommend you to start with the
&lt;a href=&quot;https://wpewebkit.org/blog/01-happy-birthday-wpe.html&quot;&gt;first post in the series&lt;/a&gt;
for an introduction, and then come back to this.&lt;/p&gt;
&lt;h2 id=&quot;dom-%2B-css-%3D-rendertree&quot; tabindex=&quot;-1&quot;&gt;DOM + CSS = RenderTree&lt;/h2&gt;
&lt;p&gt;The rendering process begins once we have the created the DOM tree for the page and
we have the CSS rules parsed. The first step to render the content of a page is to
perform what’s called the attachment, which is merging the DOM tree with the CSS rules,
in order to create the RenderTree. This RenderTree is a collection ob RenderObjects,
and each of these RenderObjects represent the elements in the DOM tree that have visual
output. RenderObjects have the capability to render the associated DOM tree node into
a surface by using the GraphicsContext class (in the case of WPE, this GraphicsContext
uses cairo to perform the rendering).&lt;/p&gt;
&lt;p&gt;Once the RenderTree is created, the layout is performed, ensuring that each of the
RenderObjects have their proper size and position set.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wpewebkit.org/assets/graphics-attachment.png&quot; alt=&quot;Simplest rendering process of a page&quot; /&gt;&lt;/p&gt;
&lt;p&gt;It would be possible to render the content of the web page just traversing this
RenderTree and painting each of the RenderElements, but there would be problems when
rendering elements that overlap each other, because the order of the elements in the
RenderTree doesn’t necessarily match the order in which they must be painted in order
to get the appropriate result. For example an element with a big zindex should be painted
last, no matter its position in the RenderTree.&lt;/p&gt;
&lt;p&gt;This is an example of how some HTML content is translated into the RenderTree
(there are some RenderElements missign here that are not relevant for the explanation).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wpewebkit.org/assets/graphics-rendertree.png&quot; alt=&quot;HTML code translated into a RenderTree&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;renderlayers&quot; tabindex=&quot;-1&quot;&gt;RenderLayers&lt;/h2&gt;
&lt;p&gt;In order to ensure that the elements of the RenderTree are rendered in the appropriate
order, the concept of RenderLayer is added. A RenderLayer represents a layer in the
document containing some elements that have to be rendered at the same depth (despite
it’s not exactly the case, you can think of each RenderLayer represening the RenderObjects
that are at a certain zindex). Each RenderObject is associated to a RenderLayer either
directly or indirectly via an ancestor RenderObject.&lt;/p&gt;
&lt;p&gt;RenderLayers are grouped into a tree, which is called the RenderLayer tree, and RenderLayer
children are sorted into two lists, those that are below the RenderLayer and those that
are above. With this we have an structure that has grouped all the RenderObjects that have
to be rendered together: they will be on top of the content that has has been rendered by
the RenderLayers below this one, and and below the content rendered by the RenderLayers
over this one.&lt;/p&gt;
&lt;p&gt;There are several conditions that can decide whether a RenderLayer is needed for some
element, it doesn’t necessarily needs to be due to the usage of zindex. They can be
required due to transparency, CSS filters, overflow, transformations, etc.&lt;/p&gt;
&lt;p&gt;Continuing with the example, these are RenderLayers that we would get for that HTML
code:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wpewebkit.org/assets/graphics-renderlayertree.png&quot; alt=&quot;HTML code translated into a RenderTree and RenderLayers&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We can see that there are four RenderLayers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The root one, corresponding to the RenderView element. This is mandatory.&lt;/li&gt;
&lt;li&gt;Another one corresponding to the first RenderBlock.&lt;/li&gt;
&lt;li&gt;One corresponding to the RenderVideo element, because video elements always get their
own RenderLayer.&lt;/li&gt;
&lt;li&gt;One corresponding to the transformed RenderBlock, because transformed elements
always require their own RenderLayer.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RenderLayers have a paint method that is able to paint all the RenderObjects associated
to the layer into a GraphicsContext (as mentioned, using cairo for this). As in the
previous case, it’s possible to paint the content of the page at this point just by
traversing the RenderLayer tree and requesting the RenderLayers to paint their content,
but in this case the result will be the correct one. Actually this is what WebKitGTK
does when it’s run with accelerated compositing disabled.&lt;/p&gt;
&lt;h2 id=&quot;layer-composition&quot; tabindex=&quot;-1&quot;&gt;Layer composition&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;While with the previous step we are already able to render the page contents, this
approach is not very efficient, specially when the page contains animations, elements
with transparency, etc. This is because in order to paint a single pixel, all the
RenderLayers need to be traversed, and those that are contributing to that pixel need
to be repainted (totally or partially), even if the content of those RenderLayers
hasn’t changed. For example, think about an animation that’s moving an element. For
each frame of that animation, the animated element needs to be repainted, but the
area that was covered by the animated element in the last frame needs to be repainted
as well. The same happens if there’s a translucent element on top of other content.
If the translucent element changes, it needs to be repainted, but the content below
the translucent element needs to be repainted as well because the blend needs to be
performed again.&lt;/p&gt;
&lt;p&gt;This would be much more efficient if the content that doesn’t change was somehow
separated from the conten that’s changing, and we could render those contents
separately. This is where the composition stage comes into action.&lt;/p&gt;
&lt;p&gt;The idea here is that we’re going to paint the RenderLayer contents into intermediate
buffers, and then compose those buffers one on top of the other to get the final result.
This last step is what we call composition. And it fixes the problems we mentioned with
animations of transparency: animations don’t require repainting several RenderLayers.
Actually moving an element just means painting one buffer with an offset during the
composition. And for transparency, we just need to perform the new blending of the two
buffers during the composition, but the RenderLayers of the content below the translucent
element don’t need to be repainted.&lt;/p&gt;
&lt;p&gt;Once we have the RenderLayer tree, we could just paint each RenderLayer in its own buffer
in order to perform the composition. But this would be a waste of memory, as not
every RenderLayer needs a buffer. We introduce here a new component, the GraphicsLayer.&lt;/p&gt;
&lt;p&gt;GraphicsLayers are a structure used to group those RenderLayers that will render into
the same buffer, and it will also contain all the information required to perform the
composition of these buffers. A RenderLayer may have a GraphicsLayer associated to
it if it requires its own buffer to render. Otherwise, it will render into an
ancestor’s buffer (the first ancestor that has a GraphicsLayer). As usual,
GraphicsLayers are structured into a tree.&lt;/p&gt;
&lt;p&gt;This is how the example code would be translated into GraphicsLayers.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wpewebkit.org/assets/graphics-graphicslayertree.png&quot; alt=&quot;HTML code translated into a RenderTree, RenderLayers and GraphicsLayers&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We can see that we have now three GraphicsLayers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The root one, which is mandatory. It belongs to the RenderView element, but the first
RenderBlock will render into this GraphicsLayer’s buffer as well.&lt;/li&gt;
&lt;li&gt;The one for the RenderVideo element, as videos are updated independently from the
rest of the content.&lt;/li&gt;
&lt;li&gt;The one for the transformed element, as the transformed elements are updated
independently from the rest of the content.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Whith this structure, now we can, render the intermediate buffers of the RenderView and
the transformed RenderBlock and we don’t need to update them anymore. Those buffers
will be composited for each frame together with the RenderVideo one. This RenderVideo
will be updating its buffer whenever a new video frame arrives, but it won’t affect
the content of the other GraphicsLayers.&lt;/p&gt;
&lt;p&gt;So now we have successfully separated the content that is changing and needs to be
updated from the content that remains constant and doesn’t need to be repainted anymore,
just composited.&lt;/p&gt;
&lt;h2 id=&quot;accelerated-compositing-and-threaded-accelerated-compositing&quot; tabindex=&quot;-1&quot;&gt;Accelerated compositing and threaded accelerated compositing&lt;/h2&gt;
&lt;p&gt;There’s something else that be done in order to increase the rendering performance, and
it’s using the GPU to perform the composition. The GPU is very optimized to perform operations
like the buffer composition that we need to do, and handle 3D transforms, blending, etc. We just
need to upload the buffers into textures and let the GPU handle the required operations.&lt;/p&gt;
&lt;p&gt;WPE does this though the usage of EGL and GLES2. In order to perform the composition,
EGL is used to greate a GLES2 EGLContext. Using that context, the intermediate buffers are
uploadede to textures, and then those textures are positioned and composited according
to their appropriate positions. This leverages the CPU of the composition work, leaving
it free to perform other tasks.&lt;/p&gt;
&lt;p&gt;This is why this step is called accelerated compositing.&lt;/p&gt;
&lt;p&gt;But there’s more.&lt;/p&gt;
&lt;p&gt;Until this point, all the steps that are performed in order to render the content of the
page are performed in the main thread. This means that while the main thread is rendering
and compositing, it’s not being able to perform other tasks, like run JS code.&lt;/p&gt;
&lt;p&gt;WPE improves this by using a thread whose only mission is to perform the composition. You
can think of it as a thread that runs a loop that composites the incoming buffers using
the GPU when there’s content to render. This is what we call threaded accelerated
compositing.&lt;/p&gt;
&lt;p&gt;This is specially useful when there’s a video or an animation running on the page:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If there’s a video running in the page, in the non threaded case, for each video frame
the main thread would need to get the frame and perform the composition with the rest
of the page content. In the threaded case, the video element delivers the frames directly
to the compositor thread, and requests a composition to be done, without the main thread
being involved at all.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If there’s an animation, in the non threaded case, for each frame of the animation
the main thread would need to calculate the animation step and then perform the composition
of the animated element with the rest of the page content. In the threaded case, the
animation is passed to the compositor thread, and the animation steps are calculated
on that thread, triggering a composition when needed. The main thread doesn’t need to
to anything besides starting the animation.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It would take another post to explain in detail how the threaded accelerated composition
is implemented on WPE, but if you’re curious about it, know that WPE uses an specialization
of the GraphicsLayer called CoordinatedGraphicsLayer in order to implement this. You
can use that as an starting point.&lt;/p&gt;
&lt;p&gt;So this is the whole process that’s performed in WPE in order to display the content
of a page. Hope it’s useful!!&lt;/p&gt;
&lt;h2 id=&quot;but-what-about-the-backends%3F&quot; tabindex=&quot;-1&quot;&gt;But what about the backends?&lt;/h2&gt;
&lt;p&gt;In &lt;a href=&quot;https://wpewebkit.org/blog/02-overview-of-wpe.html&quot;&gt;theprevious post&lt;/a&gt; there was a mention
to backends, that are used to integrate with the underlying platform. How is this
relevant to the graphics architecture?&lt;/p&gt;
&lt;p&gt;Backends have several missions when it comes to communicate with the platform, but
regarding graphics, they have two functions to achieve:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Provide a platform dependant surface that WPE will render to. This can be a normal
buffer, a wayland buffer, a native window or whatever, as long as the system EGL
implementation allows creating an EGLContext to render to it.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Process WPE indications that a new frame has been rendered, performing
whatever tasks necessary to take that frame to the display. Also notify WPE when
that frame was been displayed.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The most common example of this is a Wayland backend, that provides a Wayland buffer
to WPE for rendering. When WPE has finished rendering the content, it notifies the
backend, which sends the wayland buffer to the Wayland compositor, and notifies back to
WPE when the frame has been displayed.&lt;/p&gt;
&lt;p&gt;So, whatever platform you want to run WPE on, you need to have a backend providing
at least these capabilities.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>WPE WebKit 2.36.4 released</title>
    <link href="https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/release/wpewebkit-2.36.4.html"/>
    <updated>2022-07-05T00:00:00Z</updated>
    <id>https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/release/wpewebkit-2.36.4.html</id>
    <content type="html">&lt;p&gt;This is a bug fix release in the stable 2.36 series.&lt;/p&gt;
&lt;h3 id=&quot;what%E2%80%99s-new-in-wpe-webkit-2.36.4%3F&quot; tabindex=&quot;-1&quot;&gt;What’s new in WPE WebKit 2.36.4?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Fix the new ATSPI accessibility implementation to add the missing &lt;code&gt;Collection&lt;/code&gt; interface for the loaded document.&lt;/li&gt;
&lt;li&gt;Fix the MediaSession implementation to make the MPRIS object names more sandbox friendly, which plays better with Flatpak and WebKit’s own Bubblewrap-based sandboxing.&lt;/li&gt;
&lt;li&gt;Fix leaked Web Processes in some particular situations.&lt;/li&gt;
&lt;li&gt;Fix the build with media capture support enabled.&lt;/li&gt;
&lt;li&gt;Fix cross-compilation when targeting 64-bit ARM.&lt;/li&gt;
&lt;li&gt;Fix several crashes and rendering issues.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;checksums&quot; tabindex=&quot;-1&quot;&gt;Checksums&lt;/h4&gt;
&lt;pre&gt;
wpewebkit-2.36.4.tar.xz (24.6 MiB)
   md5sum: ba8e5f5444fd50f53906a7376b25bb26
   sha1sum: 91259642da6fe55446c3352eeeafdaa188fc14bd
   sha256sum: 307a3bedf5d4299a861f773f631c39a44c3e6276c3af37f7cbefaed2c8d7c021
&lt;/pre&gt;
</content>
  </entry>
  
  <entry>
    <title>WebKitGTK and WPE WebKit Security Advisory WSA-2022-0006</title>
    <link href="https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/security/WSA-2022-0006.html"/>
    <updated>2022-07-05T00:00:00Z</updated>
    <id>https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/security/WSA-2022-0006.html</id>
    <content type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Date Reported: &lt;strong&gt;July 05, 2022&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Advisory ID: &lt;strong&gt;WSA-2022-0006&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CVE identifiers: &lt;a href=&quot;https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/security/WSA-2022-0006.html#CVE-2022-22662&quot;&gt;CVE-2022-22662&lt;/a&gt;, &lt;a href=&quot;https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/security/WSA-2022-0006.html#CVE-2022-22677&quot;&gt;CVE-2022-22677&lt;/a&gt;,
&lt;a href=&quot;https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/security/WSA-2022-0006.html#CVE-2022-26710&quot;&gt;CVE-2022-26710&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Several vulnerabilities were discovered in WebKitGTK and WPE WebKit.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a name=&quot;CVE-2022-22662&quot; href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-22662&quot;&gt;CVE-2022-22662&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Versions affected: WebKitGTK and WPE WebKit before 2.36.0.&lt;/li&gt;
&lt;li&gt;Credit to Prakash (@1lastBr3ath) of Threat Nix.&lt;/li&gt;
&lt;li&gt;Impact: Processing maliciously crafted web content may disclose
sensitive user information. Description: A cookie management issue
was addressed with improved state management.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a name=&quot;CVE-2022-22677&quot; href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-22677&quot;&gt;CVE-2022-22677&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Versions affected: WebKitGTK and WPE WebKit before 2.36.4.&lt;/li&gt;
&lt;li&gt;Credit to an anonymous researcher.&lt;/li&gt;
&lt;li&gt;Impact: The video in a webRTC call may be interrupted if the audio
capture gets interrupted. Description: A logic issue in the handling
of concurrent media was addressed with improved state handling.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a name=&quot;CVE-2022-26710&quot; href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-26710&quot;&gt;CVE-2022-26710&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Versions affected: WebKitGTK and WPE WebKit before 2.36.4.&lt;/li&gt;
&lt;li&gt;Credit to Chijin Zhou of ShuiMuYuLin Ltd and Tsinghua wingtecher
lab.&lt;/li&gt;
&lt;li&gt;Impact: Processing maliciously crafted web content may lead to
arbitrary code execution. Description: A use after free issue was
addressed with improved memory management.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We recommend updating to the latest stable versions of WebKitGTK and WPE
WebKit. It is the best way to ensure that you are running safe versions
of WebKit. Please check our websites for information about the latest
stable releases.&lt;/p&gt;
&lt;p&gt;Further information about WebKitGTK and WPE WebKit security advisories can be found at:
&lt;a href=&quot;https://webkitgtk.org/security.html&quot;&gt;https://webkitgtk.org/security.html&lt;/a&gt; or &lt;a href=&quot;https://wpewebkit.org/security/&quot;&gt;https://wpewebkit.org/security/&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>An overview of the WPE WebKit project</title>
    <link href="https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/blog/02-overview-of-wpe.html"/>
    <updated>2022-07-01T00:00:00Z</updated>
    <id>https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/blog/02-overview-of-wpe.html</id>
    <content type="html">&lt;p&gt;In &lt;a href=&quot;https://wpewebkit.org/blog/01-happy-birthday-wpe.html&quot;&gt;the
previous post in this series&lt;/a&gt;, we explained that WPE is a WebKit
port optimized for embedded devices. In this post, we’ll dive into a
more technical overview of the different components of WPE, WebKit,
and how they all fit together. If you’re still wondering what a web
engine is or how WPE came to be, we recommend you to go back to the
first post in the series and then come back here.&lt;/p&gt;
&lt;h2 id=&quot;webkit-architecture-in-a-nutshell&quot; tabindex=&quot;-1&quot;&gt;WebKit architecture in a nutshell&lt;/h2&gt;
&lt;p&gt;To understand what makes WPE special, we first need to have a basic
understanding of the architecture of WebKit itself, and how it ties
together a given architecture/platform and a user-facing web browser.&lt;/p&gt;
&lt;p&gt;WebKit, the engine, is split into different components that
encapsulate its different parts. At the heart of it is WebCore. As the
name suggests, this contains the core features of the engine
(rendering, layout, platform access, HTML and DOM support, the
graphics layer, etc). However, some of these ultimately depend heavily
on the OS and underlying software platform in order to function. For
example: how do we actually do any I/O on different platforms? How do
we render onscreen? What’s the underlying multimedia platform and how
does it decode media and play it?&lt;/p&gt;
&lt;p&gt;WebCore handles the multitude of potential answers to these questions
by abstracting the implementation of each component and allowing port
developers to fill the gaps for each supported platforms. For example,
for rendering on Mac, Cocoa APIs implement the graphics APIs
needed. On Linux, this can be done through different implementations
via Wayland, Vulkan, etc. For networking I/O on Mac, the networking
APIs in the Foundation framework are used. On Linux, libsoup fills
that gap, and so on.&lt;/p&gt;
&lt;p&gt;On the opposite side, for browser implementors to be able to write a
browser using WebKit, an API is needed. WebKit, after all, is a
library. WebKit ports, besides providing the platform support
described above, also provide APIs that suit the target environments:
The Apple ports provide Objective-C APIs (which are then used to write
Safari and the iOS browsers, for instance), while the GTK+ port
provides a GObject-based APIs for Linux (that are used in Epiphany,
the GNOME browser, and other GNOME applications that rely on WebKit to
render HTML). All of these APIs are built on top of an internal,
middle-man, C API that is meant to make it easy for each port to
provide a high-level API for browser developers.&lt;/p&gt;
&lt;p&gt;With all this in place, it would seem that it shouldn’t be so
difficult for any vendor trying to reuse WebKit in a new platform to
support new hardware and implement a browser, right? All that you need
to do is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Implement backends that integrate with your hardware platform: for multimedia, IO, OS support, networking, graphics, etc.&lt;/li&gt;
&lt;li&gt;Write an API that you can use to plug the engine into your browser.&lt;/li&gt;
&lt;li&gt;Maintain the changes needed off-tree, that is, outside the source code tree of WebKit.&lt;/li&gt;
&lt;li&gt;Keep your implementation up-to-date with the many changes that happen in the WebKit codebase on a daily basis, so that you can update WebKit regularly and take advantage of the many bug fixes, improvements, and new features that land on WebKit continuously.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Does that sound easy? No, it’s not easy at all! In fact,
implementation of ports in this fashion is strongly discouraged and
vendors who have tried this approach in the past have had to do a huge
effort just to play catch-up with the fast-paced development of
WebKit. This is where WPE comes to the rescue.&lt;/p&gt;
&lt;h2 id=&quot;simplifying-browsers-development-in-the-diverse-embedded-world&quot; tabindex=&quot;-1&quot;&gt;Simplifying browsers development in the diverse embedded world&lt;/h2&gt;
&lt;p&gt;To simplify the task of porting WebKit to different platforms, Igalia
started working on a platform-agnostic, Linux-based, and full-featured
port of WebKit. This port relies on existing and mature platform
backends for everything that can be easily reused across platforms:
multimedia, networking, and I/O, which are already present in-tree and
are used by Linux ports, like the GTK one. For the areas that are most
likely to require hardware-specific support (that is, graphics and
input), WPE abstracts the implementation so that it can be more easily
provided out of tree, allowing implementors to avoid having to deal
with the WebKit internals more than what’s strictly needed.&lt;/p&gt;
&lt;p&gt;Additionally, WPE provides a high-level API that can be used to
implement actual browsers. This API is very similar to the WebKitGTK
API, making it easy for developers already familiar with the latter to
start working with WPE. The cog library also serves as a wrapper
around WPE to make it easier still. Once WPE was mature enough, it was
accepted by Apple as an official WebKit port, meaning that the port
lives now in-tree and takes immediate advantage of the many
improvements that land on the WebKit repository on a daily basis.&lt;/p&gt;
&lt;h2 id=&quot;how-does-wpe-integrate-with-webkit%3F&quot; tabindex=&quot;-1&quot;&gt;How does WPE integrate with WebKit?&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://wpewebkit.org/assets/wpe-architecture-diagram.png&quot; alt=&quot;A diagram of the WPE WebKit architecture&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The WPE port has several components. Some are in-tree (that is, are a
part of WebKit itself), while others are out-of-tree. Let’s examine
those components and how they relate to each other, from top to
bottom:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href=&quot;https://github.com/Igalia/cog#cog&quot;&gt;cog library&lt;/a&gt;. While not an integral part of WPE, libcog is a shell library that simplifies the task of writing a WPE browser from the scratch, by providing common functionality and helper APIs. This component also includes the cog browser, a simple WPE browser built on top of libcog that can be used as a reference or a starting point for the development of a new browser for a specific use case.&lt;/li&gt;
&lt;li&gt;The &lt;a href=&quot;https://people.igalia.com/aperez/Documentation/wpe-webkit-1.1/&quot;&gt;WebKit WPE API&lt;/a&gt;: the entry point for browser developers to the WebKit engine, provides a comprehensive GObject/C API. The cog library uses this API extensively and we recommend relying on it, but for more specific needs and more fine-tuning of the engine, working directly with the WebKit API can be often necessary. The API is stable and easy to use, especially, and for those familiar with the GTK/GNOME platform.&lt;/li&gt;
&lt;li&gt;WPE’s WebCore implementation: This part, internal to WebKit, implements an abstraction of the graphics and input layers of WebKit. This implementation relies on the libwpe library to provide the functionality required in an abstract way. Thanks to the architecture of WPE, implementors don’t need to bother with the complexities of WebCore and WebKit internals.&lt;/li&gt;
&lt;li&gt;The &lt;a href=&quot;https://github.com/WebPlatformForEmbedded/libwpe&quot;&gt;libwpe&lt;/a&gt; library. This is an out-of-tree library that provides the API required by the WPE port in a generic way to implement the graphical and input backends. Specific functionality for a concrete platform is not provided, but the library relies on the existence of a backend implementation, as is described next.&lt;/li&gt;
&lt;li&gt;Finally, a WPE backend implementation. This is where all the platform-specific code lives. Backends are loadable modules that can be chosen depending on the underlying hardware. These should provide access to graphics and input depending on the specific architecture, platform, and operating system requirements. As a reference, &lt;a href=&quot;https://github.com/Igalia/WPEBackend-fdo&quot;&gt;WPEBackend-fdo&lt;/a&gt; is a freedesktop.org-based backend, which uses Wayland and freekdesktop.org technologies, and is &lt;a href=&quot;https://wpewebkit.org/about/supported-hardware.html&quot;&gt;supported for several architectures&lt;/a&gt;, including NXP and Broadcom chipsets, like the Raspberry PI, and also regular PC architectures, easing testing and development.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An implementor interested in building a browser in a new architecture
only needs to focus on the development of the last component – a WPE
backend. Having a backend, starting the development of a
WebKit-powered browser is already much easier than it ever was!&lt;/p&gt;
&lt;p&gt;For a more detailed description of the architecture of WPE and WebKit,
check this article on &lt;a href=&quot;https://wpewebkit.org/about/architecture.html&quot;&gt;the architecture
of WPE&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;ok%2C-sounds-interesting%2C-how-do-i-get-my-hands-dirty%3F&quot; tabindex=&quot;-1&quot;&gt;OK, sounds interesting, how do I get my hands dirty?&lt;/h2&gt;
&lt;p&gt;If you have made it this far, you should give WPE a try!&lt;/p&gt;
&lt;p&gt;We have listed several on the &lt;a href=&quot;https://wpewebkit.org/about/exploring.html&quot;&gt;exploring WPE&lt;/a&gt;
page. From there, you will see that depending on how interested you
are in the project, your background, and what you’d like to do with
it, there are different ways!&lt;/p&gt;
&lt;p&gt;It can be as easy as installing WPE directly from the most popular
Linux distributions or downloading and flashing prebuilt images for
the Raspberry Pi. There are easy and flexible options like &lt;a href=&quot;https://wpewebkit.org/about/flatpak.html&quot;&gt;flatpak&lt;/a&gt;, &lt;a href=&quot;https://wpewebkit.org/about/balena-wpe.html&quot;&gt;balena&lt;/a&gt; which
you can dig into to learn more.  If you want to build WPE yourself,
you can use &lt;a href=&quot;https://github.com/Igalia/meta-webkit/wiki/WPE&quot;&gt;yocto&lt;/a&gt; and if
you’d like to contribute - that’s very welcome!&lt;/p&gt;
&lt;p&gt;Happy hacking!&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Cog 0.13.90 released</title>
    <link href="https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/release/cog-0.13.90.html"/>
    <updated>2022-06-29T00:00:00Z</updated>
    <id>https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/release/cog-0.13.90.html</id>
    <content type="html">&lt;p&gt;This is a development release leading towards the 0.14 series.&lt;/p&gt;
&lt;h3 id=&quot;what%E2%80%99s-new-in-cog-0.13.90%3F&quot; tabindex=&quot;-1&quot;&gt;What’s new in Cog 0.13.90?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;cmake: Enable libsoup3 usage by default, &lt;code&gt;USE_SOUP2=ON&lt;/code&gt; can still be specified to build against libsoup2.&lt;/li&gt;
&lt;li&gt;cmake: Require version 3.12, which is the same minimum as needed by WebKit.&lt;/li&gt;
&lt;li&gt;cmake: Link the same &lt;code&gt;wpebackend-fdo&lt;/code&gt; library in all components to avoid crashes due to multiple copies loaded with different behaviours.&lt;/li&gt;
&lt;li&gt;cmake: Fix generated &lt;code&gt;.pc&lt;/code&gt; file when using an absolute directory for the &lt;code&gt;CMAKE_INSTALL_LIBDIR&lt;/code&gt; option instead of a relative one.&lt;/li&gt;
&lt;li&gt;core: Add “Try again” button to default error pages.&lt;/li&gt;
&lt;li&gt;gtk4: Fix rendering with drivers that support OpenGL 4.&lt;/li&gt;
&lt;li&gt;wl: Avoid crashing due to missing callbacks by explicitly binding to supported versions of Wayland protocols.&lt;/li&gt;
&lt;li&gt;wl: Fix the build with &lt;code&gt;COG_WESTON_DIRECT_DISPLAY&lt;/code&gt; enabled.&lt;/li&gt;
&lt;li&gt;wl: Fix fullscreen surface dimensions when using SHM buffers.&lt;/li&gt;
&lt;li&gt;wl: Add keybindings to refresh the current page (&lt;key&gt;Ctrl-R&lt;/key&gt;, &lt;key&gt;F5&lt;/key&gt;).&lt;/li&gt;
&lt;li&gt;x11: Fix underlinking when the &lt;code&gt;--as-needed&lt;/code&gt; linker flag is in use.&lt;/li&gt;
&lt;li&gt;x11: Fix rendering in non-composited (traditional) window managers.&lt;/li&gt;
&lt;li&gt;drm, gtk4, x11: Factor out and reuse the GLES textured quad painting code.&lt;/li&gt;
&lt;li&gt;drm, wl, x11: Add refresh rate reporting to let WebKit pace rendering to match the output device.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;checksums&quot; tabindex=&quot;-1&quot;&gt;Checksums&lt;/h4&gt;
&lt;pre&gt;
cog-0.13.90.tar.xz (119.7 KiB)
   md5sum: 749f55793438c552185023a9bd744d6a
   sha1sum: 82c885e8e942a97c7bb7d7c9b6e25ceba1b462c7
   sha256sum: a7ed11a10c41a9c4ad9692730357e6d86f2544d308d96018d26f80b234e16080
&lt;/pre&gt;
</content>
  </entry>
  
  <entry>
    <title>WebKitGTK and WPE WebKit Security Advisory WSA-2022-0005</title>
    <link href="https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/security/WSA-2022-0005.html"/>
    <updated>2022-05-30T00:00:00Z</updated>
    <id>https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/security/WSA-2022-0005.html</id>
    <content type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Date Reported: &lt;strong&gt;May 30, 2022&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Advisory ID: &lt;strong&gt;WSA-2022-0005&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CVE identifiers: &lt;a href=&quot;https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/security/WSA-2022-0005.html#CVE-2022-26700&quot;&gt;CVE-2022-26700&lt;/a&gt;, &lt;a href=&quot;https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/security/WSA-2022-0005.html#CVE-2022-26709&quot;&gt;CVE-2022-26709&lt;/a&gt;,
&lt;a href=&quot;https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/security/WSA-2022-0005.html#CVE-2022-26717&quot;&gt;CVE-2022-26717&lt;/a&gt;, &lt;a href=&quot;https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/security/WSA-2022-0005.html#CVE-2022-26716&quot;&gt;CVE-2022-26716&lt;/a&gt;,
&lt;a href=&quot;https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/security/WSA-2022-0005.html#CVE-2022-26719&quot;&gt;CVE-2022-26719&lt;/a&gt;, &lt;a href=&quot;https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/security/WSA-2022-0005.html#CVE-2022-30293&quot;&gt;CVE-2022-30293&lt;/a&gt;,
&lt;a href=&quot;https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/security/WSA-2022-0005.html#CVE-2022-30294&quot;&gt;CVE-2022-30294&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Several vulnerabilities were discovered in WebKitGTK and WPE WebKit.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a name=&quot;CVE-2022-26700&quot; href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-26700&quot;&gt;CVE-2022-26700&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Versions affected: WebKitGTK and WPE WebKit before 2.36.3.&lt;/li&gt;
&lt;li&gt;Credit to ryuzaki.&lt;/li&gt;
&lt;li&gt;Impact: Processing maliciously crafted web content may lead to code
execution. Description: A memory corruption issue was addressed with
improved state management.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a name=&quot;CVE-2022-26709&quot; href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-26709&quot;&gt;CVE-2022-26709&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Versions affected: WebKitGTK and WPE WebKit before 2.36.3.&lt;/li&gt;
&lt;li&gt;Credit to Chijin Zhou of ShuiMuYuLin Ltd and Tsinghua wingtecher
lab.&lt;/li&gt;
&lt;li&gt;Impact: Processing maliciously crafted web content may lead to
arbitrary code execution. Description: A use after free issue was
addressed with improved memory management.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a name=&quot;CVE-2022-26717&quot; href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-26717&quot;&gt;CVE-2022-26717&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Versions affected: WebKitGTK and WPE WebKit before 2.36.3.&lt;/li&gt;
&lt;li&gt;Credit to Jeonghoon Shin of Theori.&lt;/li&gt;
&lt;li&gt;Impact: Processing maliciously crafted web content may lead to
arbitrary code execution. Description: A use after free issue was
addressed with improved memory management.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a name=&quot;CVE-2022-26716&quot; href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-26716&quot;&gt;CVE-2022-26716&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Versions affected: WebKitGTK and WPE WebKit before 2.36.3.&lt;/li&gt;
&lt;li&gt;Credit to SorryMybad (@S0rryMybad) of Kunlun Lab.&lt;/li&gt;
&lt;li&gt;Impact: Processing maliciously crafted web content may lead to
arbitrary code execution. Description: A memory corruption issue was
addressed with improved state management.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a name=&quot;CVE-2022-26719&quot; href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-26719&quot;&gt;CVE-2022-26719&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Versions affected: WebKitGTK and WPE WebKit before 2.36.3.&lt;/li&gt;
&lt;li&gt;Credit to Dongzhuo Zhao working with ADLab of Venustech.&lt;/li&gt;
&lt;li&gt;Impact: Processing maliciously crafted web content may lead to
arbitrary code execution. Description: A memory corruption issue was
addressed with improved state management.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a name=&quot;CVE-2022-30293&quot; href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-30293&quot;&gt;CVE-2022-30293&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Versions affected: WebKitGTK and WPE WebKit before 2.36.1.&lt;/li&gt;
&lt;li&gt;Credit to Chijin Zhou of ShuiMuYuLin Ltd and Tsinghua wingtecher
lab.&lt;/li&gt;
&lt;li&gt;Impact: Processing maliciously crafted web content may lead to
arbitrary code execution or to a denial of service (application
crash). Description: A memory corruption issue that could cause a
heap use after free or a heap buffer overflow in
WebCore::TextureMapperLayer::setContentsLayer was addressed with
improved state management.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a name=&quot;CVE-2022-30294&quot; href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-30294&quot;&gt;CVE-2022-30294&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Versions affected: WebKitGTK and WPE WebKit before 2.36.1.&lt;/li&gt;
&lt;li&gt;Credit to Chijin Zhou of ShuiMuYuLin Ltd and Tsinghua wingtecher
lab.&lt;/li&gt;
&lt;li&gt;Impact: Processing maliciously crafted web content may lead to
arbitrary code execution or to a denial of service (application
crash). Description: A memory corruption issue that could cause a
heap use after free or a heap buffer overflow in
WebCore::TextureMapperLayer::setContentsLayer was addressed with
improved state management. This is the same issue than
CVE-2022-30293.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We recommend updating to the latest stable versions of WebKitGTK and WPE
WebKit. It is the best way to ensure that you are running safe versions
of WebKit. Please check our websites for information about the latest
stable releases.&lt;/p&gt;
&lt;p&gt;Further information about WebKitGTK and WPE WebKit security advisories can be found at:
&lt;a href=&quot;https://webkitgtk.org/security.html&quot;&gt;https://webkitgtk.org/security.html&lt;/a&gt; or &lt;a href=&quot;https://wpewebkit.org/security/&quot;&gt;https://wpewebkit.org/security/&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>WPE WebKit 2.36.3 released</title>
    <link href="https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/release/wpewebkit-2.36.3.html"/>
    <updated>2022-05-28T00:00:00Z</updated>
    <id>https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/release/wpewebkit-2.36.3.html</id>
    <content type="html">&lt;p&gt;This is a bug fix release in the stable 2.36 series.&lt;/p&gt;
&lt;h3 id=&quot;what%E2%80%99s-new-in-wpe-webkit-2.36.3%3F&quot; tabindex=&quot;-1&quot;&gt;What’s new in WPE WebKit 2.36.3?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Support capturing already encoded video streams, which takes advantage
of encoding done in hardware by devices which support this feature.&lt;/li&gt;
&lt;li&gt;Avoid using experimental GStreamer elements for video demuxing.&lt;/li&gt;
&lt;li&gt;Avoid using the legacy GStreamer VA-API decoding plug-ins, which often
cause rendering issues and are not much maintained. Their usage can be
re-enabled setting &lt;code&gt;WEBKIT_GST_ENABLE_LEGACY_VAAPI=1&lt;/code&gt; in the environment.&lt;/li&gt;
&lt;li&gt;Fix playback of YouTube streams which use dynamic ad insertion.&lt;/li&gt;
&lt;li&gt;Fix display capture with Pipewire.&lt;/li&gt;
&lt;li&gt;Fix the build without the X11 target when X11 headers are not present.&lt;/li&gt;
&lt;li&gt;Fix several crashes and rendering issues.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;checksums&quot; tabindex=&quot;-1&quot;&gt;Checksums&lt;/h4&gt;
&lt;pre&gt;
wpewebkit-2.36.3.tar.xz (24.6 MiB)
   md5sum: 8bc53f86a3489da31fdbb581e1b87f7a
   sha1sum: 44a3d99ae48481917ddc478c5f91e6a4faa21ff5
   sha256sum: 66275debca7497daff3a7826734cd56262a807adb76c5dccdf257c89968c2fc8
&lt;/pre&gt;
</content>
  </entry>
  
  <entry>
    <title>WPE WebKit 2.36.2 released</title>
    <link href="https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/release/wpewebkit-2.36.2.html"/>
    <updated>2022-05-18T00:00:00Z</updated>
    <id>https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/release/wpewebkit-2.36.2.html</id>
    <content type="html">&lt;p&gt;This is a bug fix release in the stable 2.36 series.&lt;/p&gt;
&lt;h3 id=&quot;what%E2%80%99s-new-in-wpe-webkit-2.36.2%3F&quot; tabindex=&quot;-1&quot;&gt;What’s new in WPE WebKit 2.36.2?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Fix some pages showing empty content boxes when using threaded rendering.&lt;/li&gt;
&lt;li&gt;Fix the build with accessibility disabled.&lt;/li&gt;
&lt;li&gt;Fix the build with newer Ruby versions.&lt;/li&gt;
&lt;li&gt;Fix several crashes and rendering issues.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;checksums&quot; tabindex=&quot;-1&quot;&gt;Checksums&lt;/h4&gt;
&lt;pre&gt;
wpewebkit-2.36.2.tar.xz (24.5 MiB)
   md5sum: bcfb465ae085835ae96c68fddc85ca44
   sha1sum: 1a5a6b7b5e94f4ea7e3462d6bdb5de7efa678f74
   sha256sum: 959519562701e2005f2767a62e85977d6c3e65858709b376c89d8e33502febb9
&lt;/pre&gt;
</content>
  </entry>
  
  <entry>
    <title>libwpe 1.13.2 released</title>
    <link href="https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/release/libwpe-1.13.2.html"/>
    <updated>2022-05-16T00:00:00Z</updated>
    <id>https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/release/libwpe-1.13.2.html</id>
    <content type="html">&lt;p&gt;This is a development release leading towards the 1.14 series.&lt;/p&gt;
&lt;h3 id=&quot;what%E2%80%99s-new-in-libwpe-1.13.2%3F&quot; tabindex=&quot;-1&quot;&gt;What’s new in libwpe 1.13.2?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;New API to configure the target refresh rate of view backends.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;checksums&quot; tabindex=&quot;-1&quot;&gt;Checksums&lt;/h4&gt;
&lt;pre&gt;
libwpe-1.13.2.tar.xz (59.4 KiB)
   md5sum: 31b267649eb1a5f472b07a66adab86e1
   sha1sum: 5de7bc3e4dd9f8d94df84395106547c0a0a904f9
   sha256sum: efcd97dc0f95ff7a506483ba3df944669cdc602b3fc45c9fd676dee0f8f92cac
&lt;/pre&gt;
</content>
  </entry>
  
  <entry>
    <title>libwpe 1.13.1 released</title>
    <link href="https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/release/libwpe-1.13.1.html"/>
    <updated>2022-05-12T00:00:00Z</updated>
    <id>https://wpewebkit.org/wpewebkit.org/magomez/add-graphics-post/release/libwpe-1.13.1.html</id>
    <content type="html">&lt;p&gt;This is the first development release leading towards the 1.14 series.&lt;/p&gt;
&lt;h3 id=&quot;what%E2%80%99s-new-in-libwpe-1.13.1%3F&quot; tabindex=&quot;-1&quot;&gt;What’s new in libwpe 1.13.1?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;New API to provide input events to be treated by WebKit as gamepad inputs.&lt;/li&gt;
&lt;li&gt;New &lt;code&gt;WPE_ENABLE_XKB&lt;/code&gt; build option, enabled by default, which can be used
to completely avoid usage of &lt;code&gt;libxkbcommon&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Allow libwpe to be built as a static library. The rest of the code
linked with the static library must provide the &lt;code&gt;_wpe_loader_interface&lt;/code&gt;
symbol, as &lt;code&gt;dlopen()&lt;/code&gt; will not be used.&lt;/li&gt;
&lt;li&gt;Allow building libwpe within a larger CMake project.&lt;/li&gt;
&lt;li&gt;Update the required Meson version to 0.55.0&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;checksums&quot; tabindex=&quot;-1&quot;&gt;Checksums&lt;/h4&gt;
&lt;pre&gt;
libwpe-1.13.1.tar.xz (59.3 KiB)
   md5sum: 6870daa1c2b5d9963b6b0d715e0c0714
   sha1sum: 2a3be69f2f49011cc593a498d4fe309e0bc8c3ff
   sha256sum: c3f55c8b98f1dc8ea7456880744098f5054ff5deba92a10dc93728710fbe9857
&lt;/pre&gt;
</content>
  </entry>
</feed>