<!DOCTYPE html>
<html prefix="og: https://ogp.me/ns#">

  <head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="author" content="">

  <title>WPE Graphics architecture</title>
  <link rel="canonical" href="https://igalia.github.io/wpewebkit.org/magomez/add-graphics-post/blog/03-wpe-graphics-architecture.html">
  <link rel="alternate" type="application/rss+xml" title="" href="https://igalia.github.io/wpewebkit.org/magomez/add-graphics-post/feed.xml">
  <meta property="og:url" content="https://igalia.github.io/wpewebkit.org/magomez/add-graphics-post/blog/03-wpe-graphics-architecture.html">
  <meta property="og:title" content="WPE Graphics architecture">
  <meta property="og:image" content="https://igalia.github.io/wpewebkit.org/magomez/add-graphics-post/assets/twitter_Profile_WhiteBg_400px.png">
  <meta property="og:image:secure_url" content="https://igalia.github.io/wpewebkit.org/magomez/add-graphics-post/assets/twitter_Profile_WhiteBg_400px.png">
  <meta property="og:image:alt" content="WPE logo">
  <meta property="og:image:type" content="image/png">
  <meta property="og:image:width" content="400">
  <meta property="og:image:height" content="400">
  <meta property="og:type" content="article">
  <meta property="article:published_time" content="2022-07-15T00:00:00.000Z">
  <meta property="article:tag" content="blogpost">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@WPEWebKit">

  <!-- Bootstrap Core CSS -->
  <link rel="stylesheet" href="/wpewebkit.org/magomez/add-graphics-post/vendor/bootstrap/css/bootstrap.min.css">

  <!-- Custom Fonts -->
  <link rel="stylesheet" href="/wpewebkit.org/magomez/add-graphics-post/vendor/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/wpewebkit.org/magomez/add-graphics-post/vendor/simple-line-icons/css/simple-line-icons.css">
  <link rel="stylesheet" href="/wpewebkit.org/magomez/add-graphics-post/css/fonts.css">

  <!-- Custom CSS -->
  <link rel="stylesheet" href="/wpewebkit.org/magomez/add-graphics-post/css/stylish-portfolio.css">
  
  <!-- Matomo -->
  <script type="text/javascript">
    var _paq = window._paq = window._paq || [];
    /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
      var u="//stats.igalia.com/";
      _paq.push(['setTrackerUrl', u+'matomo.php']);
      _paq.push(['setSiteId', '6']);
      var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
      g.type='text/javascript'; g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
    })();
  </script>
  <!-- End Matomo Code -->
</head>


  <body id="page-top">

    <nav class="navbar navbar-expand-lg navbar-light bg-light">
  <a class="navbar-brand logo" href="/wpewebkit.org/magomez/add-graphics-post/"><img width="200" src="/wpewebkit.org/magomez/add-graphics-post/assets/svg/blue_Web_Logo.svg" alt=""></a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
 
  <div class="collapse navbar-collapse" id="navbarSupportedContent">
    <ul class="navbar-nav">
      <li class="nav-item active">
        <a class="nav-link" href="/wpewebkit.org/magomez/add-graphics-post/">Home</a>
      </li>
      <li class="nav-item">
          <a class="nav-link" href="/wpewebkit.org/magomez/add-graphics-post/blog">Blog</a>
      </li>
      <li class="nav-item dropdown">
        <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
          Documentation
        </a>
        <div class="dropdown-menu" aria-labelledby="navbarDropdown">
          <a class="dropdown-item" href="/wpewebkit.org/magomez/add-graphics-post/about/exploring.html">Explore WPE / Embedded</a>
          <a class="dropdown-item" href="/wpewebkit.org/magomez/add-graphics-post/about/supported-hardware.html">Supported Hardware</a>
          <a class="dropdown-item" href="/wpewebkit.org/magomez/add-graphics-post/about/a-good-choice.html">Why Choose WPE</a>
          <a class="dropdown-item" href="/wpewebkit.org/magomez/add-graphics-post/about/architecture.html">WPE Design</a>
          <a class="dropdown-item" href="/wpewebkit.org/magomez/add-graphics-post/about/faq.html">FAQ</a>
          <div class="dropdown-divider"></div>
          <a class="dropdown-item" href="/wpewebkit.org/magomez/add-graphics-post/about/builds.html">Build it</a>
          <a class="dropdown-item" href="/wpewebkit.org/magomez/add-graphics-post/release/schedule">Release Schedule</a>
        </div>
      </li>
      <li class="nav-item active">
        <a class="nav-link" href="/wpewebkit.org/magomez/add-graphics-post/code">Code</a>
      </li>
      </li>
    </ul>
  </div>
</nav>



    <div itemscope itemtype="http://schema.org/TechArticle">

<meta itemprop="creativeWorkStatus" content="Published">
<meta itemprop="isAccessibleForFree" content="True">
<meta itemprop="publisher" content="WPE Team">
<meta itemprop="author" content="WPE Team">
<meta itemprop="url" content="https://igalia.github.io/wpewebkit.org/magomez/add-graphics-post/blog/03-wpe-graphics-architecture.html">

<section class="content-section bg-primary text-white small-section">
  <div class="container text-center">
    <div class="content-section-heading">
      
        <h3 class="text-secondary mb-0"
            itemprop="dateCreated">Fri Jul 15 2022</h3>
        <meta itemprop="datePublished" content="Fri Jul 15 2022">
      
      <h2 itemprop="headline">WPE Graphics architecture</h2>
	  
    </div>
  </div>
</section>

<section class="content-section bg-light small-section">
  <div class="container text-center">
    <div class="row">
      <div class="col-lg-10 mx-auto lead text-left" itemprop="articleBody">

        <p>Following <a href="/blog/02-overview-of-wpe.html">the
previous post in the series about WPE</a> where we talked about the WPE components,
this post will explain briefly the WPE graphics architecture, and how the engine
is able to render HTML content into the display. If you haven’t read the previous
entries in this blog post series about WPE, we recommend you to start with the
<a href="/blog/01-happy-birthday-wpe.html">first post in the series</a>
for an introduction, and then come back to this.</p>
<h2 id="dom-%2B-css-%3D-rendertree" tabindex="-1">DOM + CSS = RenderTree</h2>
<p>The rendering process begins once we have the created the DOM tree for the page and
we have the CSS rules parsed. The first step to render the content of a page is to
perform what’s called the attachment, which is merging the DOM tree with the CSS rules,
in order to create the RenderTree. This RenderTree is a collection ob RenderObjects,
and each of these RenderObjects represent the elements in the DOM tree that have visual
output. RenderObjects have the capability to render the associated DOM tree node into
a surface by using the GraphicsContext class (in the case of WPE, this GraphicsContext
uses cairo to perform the rendering).</p>
<p>Once the RenderTree is created, the layout is performed, ensuring that each of the
RenderObjects have their proper size and position set.</p>
<p><img src="/assets/graphics-attachment.png" alt="Simplest rendering process of a page"></p>
<p>It would be possible to render the content of the web page just traversing this
RenderTree and painting each of the RenderElements, but there would be problems when
rendering elements that overlap each other, because the order of the elements in the
RenderTree doesn’t necessarily match the order in which they must be painted in order
to get the appropriate result. For example an element with a big zindex should be painted
last, no matter its position in the RenderTree.</p>
<p>This is an example of how some HTML content is translated into the RenderTree
(there are some RenderElements missign here that are not relevant for the explanation).</p>
<p><img src="/assets/graphics-rendertree.png" alt="HTML code translated into a RenderTree"></p>
<h2 id="renderlayers" tabindex="-1">RenderLayers</h2>
<p>In order to ensure that the elements of the RenderTree are rendered in the appropriate
order, the concept of RenderLayer is added. A RenderLayer represents a layer in the
document containing some elements that have to be rendered at the same depth (despite
it’s not exactly the case, you can think of each RenderLayer represening the RenderObjects
that are at a certain zindex). Each RenderObject is associated to a RenderLayer either
directly or indirectly via an ancestor RenderObject.</p>
<p>RenderLayers are grouped into a tree, which is called the RenderLayer tree, and RenderLayer
children are sorted into two lists, those that are below the RenderLayer and those that
are above. With this we have an structure that has grouped all the RenderObjects that have
to be rendered together: they will be on top of the content that has has been rendered by
the RenderLayers below this one, and and below the content rendered by the RenderLayers
over this one.</p>
<p>There are several conditions that can decide whether a RenderLayer is needed for some
element, it doesn’t necessarily needs to be due to the usage of zindex. They can be
required due to transparency, CSS filters, overflow, transformations, etc.</p>
<p>Continuing with the example, these are RenderLayers that we would get for that HTML
code:</p>
<p><img src="/assets/graphics-renderlayertree.png" alt="HTML code translated into a RenderTree and RenderLayers"></p>
<p>We can see that there are four RenderLayers:</p>
<ul>
<li>The root one, corresponding to the RenderView element. This is mandatory.</li>
<li>Another one corresponding to the first RenderBlock.</li>
<li>One corresponding to the RenderVideo element, because video elements always get their
own RenderLayer.</li>
<li>One corresponding to the transformed RenderBlock, because transformed elements
always require their own RenderLayer.</li>
</ul>
<p>RenderLayers have a paint method that is able to paint all the RenderObjects associated
to the layer into a GraphicsContext (as mentioned, using cairo for this). As in the
previous case, it’s possible to paint the content of the page at this point just by
traversing the RenderLayer tree and requesting the RenderLayers to paint their content,
but in this case the result will be the correct one. Actually this is what WebKitGTK
does when it’s run with accelerated compositing disabled.</p>
<h2 id="layer-composition" tabindex="-1">Layer composition</h2>
<hr>
<p>While with the previous step we are already able to render the page contents, this
approach is not very efficient, specially when the page contains animations, elements
with transparency, etc. This is because in order to paint a single pixel, all the
RenderLayers need to be traversed, and those that are contributing to that pixel need
to be repainted (totally or partially), even if the content of those RenderLayers
hasn’t changed. For example, think about an animation that’s moving an element. For
each frame of that animation, the animated element needs to be repainted, but the
area that was covered by the animated element in the last frame needs to be repainted
as well. The same happens if there’s a translucent element on top of other content.
If the translucent element changes, it needs to be repainted, but the content below
the translucent element needs to be repainted as well because the blend needs to be
performed again.</p>
<p>This would be much more efficient if the content that doesn’t change was somehow
separated from the conten that’s changing, and we could render those contents
separately. This is where the composition stage comes into action.</p>
<p>The idea here is that we’re going to paint the RenderLayer contents into intermediate
buffers, and then compose those buffers one on top of the other to get the final result.
This last step is what we call composition. And it fixes the problems we mentioned with
animations of transparency: animations don’t require repainting several RenderLayers.
Actually moving an element just means painting one buffer with an offset during the
composition. And for transparency, we just need to perform the new blending of the two
buffers during the composition, but the RenderLayers of the content below the translucent
element don’t need to be repainted.</p>
<p>Once we have the RenderLayer tree, we could just paint each RenderLayer in its own buffer
in order to perform the composition. But this would be a waste of memory, as not
every RenderLayer needs a buffer. We introduce here a new component, the GraphicsLayer.</p>
<p>GraphicsLayers are a structure used to group those RenderLayers that will render into
the same buffer, and it will also contain all the information required to perform the
composition of these buffers. A RenderLayer may have a GraphicsLayer associated to
it if it requires its own buffer to render. Otherwise, it will render into an
ancestor’s buffer (the first ancestor that has a GraphicsLayer). As usual,
GraphicsLayers are structured into a tree.</p>
<p>This is how the example code would be translated into GraphicsLayers.</p>
<p><img src="/assets/graphics-graphicslayertree.png" alt="HTML code translated into a RenderTree, RenderLayers and GraphicsLayers"></p>
<p>We can see that we have now three GraphicsLayers:</p>
<ul>
<li>The root one, which is mandatory. It belongs to the RenderView element, but the first
RenderBlock will render into this GraphicsLayer’s buffer as well.</li>
<li>The one for the RenderVideo element, as videos are updated independently from the
rest of the content.</li>
<li>The one for the transformed element, as the transformed elements are updated
independently from the rest of the content.</li>
</ul>
<p>Whith this structure, now we can, render the intermediate buffers of the RenderView and
the transformed RenderBlock and we don’t need to update them anymore. Those buffers
will be composited for each frame together with the RenderVideo one. This RenderVideo
will be updating its buffer whenever a new video frame arrives, but it won’t affect
the content of the other GraphicsLayers.</p>
<p>So now we have successfully separated the content that is changing and needs to be
updated from the content that remains constant and doesn’t need to be repainted anymore,
just composited.</p>
<h2 id="accelerated-compositing-and-threaded-accelerated-compositing" tabindex="-1">Accelerated compositing and threaded accelerated compositing</h2>
<p>There’s something else that be done in order to increase the rendering performance, and
it’s using the GPU to perform the composition. The GPU is very optimized to perform operations
like the buffer composition that we need to do, and handle 3D transforms, blending, etc. We just
need to upload the buffers into textures and let the GPU handle the required operations.</p>
<p>WPE does this though the usage of EGL and GLES2. In order to perform the composition,
EGL is used to greate a GLES2 EGLContext. Using that context, the intermediate buffers are
uploadede to textures, and then those textures are positioned and composited according
to their appropriate positions. This leverages the CPU of the composition work, leaving
it free to perform other tasks.</p>
<p>This is why this step is called accelerated compositing.</p>
<p>But there’s more.</p>
<p>Until this point, all the steps that are performed in order to render the content of the
page are performed in the main thread. This means that while the main thread is rendering
and compositing, it’s not being able to perform other tasks, like run JS code.</p>
<p>WPE improves this by using a thread whose only mission is to perform the composition. You
can think of it as a thread that runs a loop that composites the incoming buffers using
the GPU when there’s content to render. This is what we call threaded accelerated
compositing.</p>
<p>This is specially useful when there’s a video or an animation running on the page:</p>
<ul>
<li>
<p>If there’s a video running in the page, in the non threaded case, for each video frame
the main thread would need to get the frame and perform the composition with the rest
of the page content. In the threaded case, the video element delivers the frames directly
to the compositor thread, and requests a composition to be done, without the main thread
being involved at all.</p>
</li>
<li>
<p>If there’s an animation, in the non threaded case, for each frame of the animation
the main thread would need to calculate the animation step and then perform the composition
of the animated element with the rest of the page content. In the threaded case, the
animation is passed to the compositor thread, and the animation steps are calculated
on that thread, triggering a composition when needed. The main thread doesn’t need to
to anything besides starting the animation.</p>
</li>
</ul>
<p>It would take another post to explain in detail how the threaded accelerated composition
is implemented on WPE, but if you’re curious about it, know that WPE uses an specialization
of the GraphicsLayer called CoordinatedGraphicsLayer in order to implement this. You
can use that as an starting point.</p>
<p>So this is the whole process that’s performed in WPE in order to display the content
of a page. Hope it’s useful!!</p>
<h2 id="but-what-about-the-backends%3F" tabindex="-1">But what about the backends?</h2>
<p>In <a href="/blog/02-overview-of-wpe.html">theprevious post</a> there was a mention
to backends, that are used to integrate with the underlying platform. How is this
relevant to the graphics architecture?</p>
<p>Backends have several missions when it comes to communicate with the platform, but
regarding graphics, they have two functions to achieve:</p>
<ul>
<li>
<p>Provide a platform dependant surface that WPE will render to. This can be a normal
buffer, a wayland buffer, a native window or whatever, as long as the system EGL
implementation allows creating an EGLContext to render to it.</p>
</li>
<li>
<p>Process WPE indications that a new frame has been rendered, performing
whatever tasks necessary to take that frame to the display. Also notify WPE when
that frame was been displayed.</p>
</li>
</ul>
<p>The most common example of this is a Wayland backend, that provides a Wayland buffer
to WPE for rendering. When WPE has finished rendering the content, it notifies the
backend, which sends the wayland buffer to the Wayland compositor, and notifies back to
WPE when the frame has been displayed.</p>
<p>So, whatever platform you want to run WPE on, you need to have a backend providing
at least these capabilities.</p>


        <p class="text-right"><a class="btn btn-primary" href="/wpewebkit.org/magomez/add-graphics-post/"><i class="icon-home mr-1"></i> Home</a></p>
      </div>
    </div>
  </div>
</section>

<!-- For blog posts -->

<section class="content-section bg-light small-section">
  <div class="container">
    <div class="row">
      <div class="col-lg-10 mx-auto text-muted text-left align-text-top">
        <hr class="author-line">
        <div class="card">
          <span>
            This article was written by <a href="https://www.igalia.com/team/magomez">Miguel Gómez</a>. <br><br>Miguel has been contributing to WebKit and WPE for almost ten years now, focusing specially on the graphics part of the code.
          </span>
        </div>
      </div>
    </div>
  </div>
</section>



</div>


    <!-- Footer -->
<footer class="footer">
  <a class="navbar-brand" href="/"><img width="200" src="/wpewebkit.org/magomez/add-graphics-post/assets/svg/blue_Web_Logo.svg"></a>
  <nav class="social">
    Connect on 
    <a href="https://twitter.com/WPEWebKit">Twitter</a> • 
    <a href="https://lists.webkit.org/mailman/listinfo/webkit-wpe">mailing list: webkit-wpe</a> • 
    <a href="https://webchat.oftc.net/?channels=wpe">OFTC: #wpe</a> • 
    <a href="https://matrix.to/#/#wpe:matrix.org">Matrix: #wpe:matrix.org</a>
  </nav>
  <p class="text-muted small mb-0">Copyright &copy; 2018-2022 The WPE WebKit Team | Hosting kindly provided by <a href="https://www.igalia.com">Igalia</a>.</p>
</footer>

  <script src="/wpewebkit.org/magomez/add-graphics-post/vendor/jquery/jquery.js"></script>
  <script src="/wpewebkit.org/magomez/add-graphics-post/vendor/bootstrap/js/bootstrap.js"></script>

  </body>
</html>
